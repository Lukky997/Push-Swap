// printf("Current a : %d | Target current_a : %d\n", current_a->number, current_a->target_node->number);
pb()
pb()
while (liste !trie)
{
	calcul target
	calcul cost
	algo pour push l'element;
}

Calculer le cost :

- Calculer la position de chaque element dans pile a et pile B
	- savoir si l'element est au dessus ou au dessous de la mediane
	par rapport a la position
Trouver le cout de current a et la target e current a pour q'il soit
a la position 0 de la pile





void	rotate_to_min_top(t_pile *a)
{
	t_element *current = a->first;
	t_element *min = current;
	int		index = 0;
	int		i = 0;

	while (current)
	{
		if (current->number < min->number)
		{
			min = current;
			index = i;
		}
		current = current->next;
		i++;
	}

	if (index <= a->nb_element / 2)
	{
		while (a->first != min)
			ra(a);
	}
	else
	{
		while (a->first != min)
			rra(a);
	}
}





void	find_target(t_pile *from, t_pile *to)
{
	t_element	*current_from;
	t_element	*current_to;
	t_element	*best_target;

	current_from = from->first;
	while (current_from)
	{
		best_target = NULL;
		current_to = to->first;
		while (current_to)
		{
			if (current_from->number < current_to->number)
			{
				if (!best_target || current_to->number < best_target->number)
					best_target = current_to;
			}
			current_to = current_to->next;
		}
		if (!best_target)
			best_target = to->smallest;
		current_from->target_node = best_target;
		current_from = current_from->next;
	}
}

